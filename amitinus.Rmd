---
title: "Союзный короед в припоселковых кедровниках"
output:
  word_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE, echo = FALSE}
knitr::opts_chunk$set(include=FALSE, echo = FALSE, warnings=FALSE, message=FALSE)
```

```{r clear_env}
rm(list=ls())
```

# Введение

Обработка материалов, собранных летом 2021 года в припоселковых кедровниках окрестностей Томска.

**Цель**: установить связи состояния древостоя и популяционных характеристик союзного короеда *Ips amitinus* с таксационными характеристиками древостоя, болезнями деревьев, свойствами почвы (богатство, увлажнённость и пр. по экологическим шкалам; pH, содержание отдельных веществ; дыхание почвы), характеристиками радиального прироста, чувствительностью к погодным условиям.

**Задачи**:

-   выделить факторы, наиболее тесно связанные с характеристиками популяции и состоянием древостоя в очагах союзного короеда;
-   описать эти зависимости аналитически.

# Подготовка к работе

## Загрузка библиотек

Для предподготовки `mice`, для анализа главных компонент `FactoMineR`, для создания линейной модели `car` и `MASS`, для исследования структуры связей между переменными `igraph`.

```{r libraries}
library('mice')               # mice
library('FactoMineR')         # PCA 
library('igraph')             # plot.igraph, graph_from_adjacency_matrix, E, V
library('car')                # vif
library('MASS')               # stepAIC
```

## Загрузка и подготовка данных

| Предварительный этап работ показал, что Лучаново лучше выбросить, так как оно сильно искажает результаты. Видимо, там сказалось влияние мощного внешнего фактора -- дефолиации сибирским шелкопрядом, которое маскирует всё остальное. 

| Также нет смысла сохранять данные о корреляциях прироста с погодой для отдельных временных промежутков: интерпретации они, как показала предыдущая итерация, не помогают. Напротив, занимая место и отвлекая внимание, они препятствуют пониманию сложившейся картины. 

| Удалим и данные о поражении *Fomes fomentarius* (поражает лиственные породы) и ведьмиными мётлами (ржавчинный рак пихты, только на пихте). 

```{r data}
# загрузка данных
data <- read.csv2('C:/Users/user/YandexDisk/Важные документы/Исходные данные для статей/Союзный/data.csv', row.names = 1)
# удаление Лучаново
data <- data[rownames(data) != 'Luchanovo', ]
# Удаление данных о корреляциях с погодой на отдельных временных промежутках, 
# поражённости настоящим трутовиком и ржавчинным раком.
data <- data[, -c(21, 28, 68:119)]
# вывод на экран сообщения об объёме данных
cat('Всего рассмотрим ', nrow(data), ' пробных площадей и ', ncol(data), 
    ' признаков.')
```

```{r character_data}
# Создадим вектор с названиями столбцов, где данные представлены 
# в текстовом формате (для удобства дальнейшей работы):
# сначала собственно создание вектора, 
character_col <- vector(mode='integer', length=0)
# а в цикле – его заполнение
for(i in 1:ncol(data)) { 
  # если mode(df$col)=='character', то добавляем номер столбца в `character_col`
  if(is.character(data[, i])) character_col <- append(character_col, i)
}
rm(i)
```

Заполним имеющиеся пропуски в данных (почва по Петухово 1 и что-то там по почве в Аркашёво) с помощью функции `mice` (метод predictice mean matching).

```{r impute_by_mice, warning=FALSE}
# Рассчитаем значения пропущенных данных
tmp <- mice(data, method='pmm', printFlag=F, seed=1980)
# Заполним пропуски
data <- complete(tmp)
# Удалим результаты работы функций `mice`, чтобы не мешали
rm(tmp) 
```

Проверка того, как отработал алгоритм `mice`.

```{r check_na_col_mice}
# Создаём вектор для подсчёта количества пропусков в столбце
missed_col <- vector(length=0)
# В цикле ищем столбцы с пропусками
for(i in 1:ncol(data)) {
  # Проверим наличие NA функцией суммы 
  # (TRUE при суммировании обрабатывается как единица); 
  # если сумма больше нуля (т.е., в столбце как минимум одно NA), 
  # добавляем номер столбца к вектору `missed_col`. 
  if(sum(is.na(data[i]))>0) missed_col <- append(missed_col, i)
}
rm(i)
# Проверка результата поиска: если длина `missed_col` ненулевая, 
if(length(missed_col) > 0) {
  # то выводим на экран столбцы с пропусками, 
  data[, missed_col]
  # а если она равна нулю, то 
} else {
  # выводим сообщение об отсутствии пропусков и удаляем `missed_col`. 
  cat('Пропусков нет')
  rm(missed_col)
}
```

Из-за коллинеарности столбцов пропущенные данные по трём из них оказались не заполнены. Придётся заполнить пропуски в них средним по столбцу, чтобы не терять остальные данные по пробной площади.

```{r impute_by_mean}
# Заполняем в цикле: 
for(i in 1:length(missed_col)) { 
  # на место пропуска в i-м столбце вставляем среднее по столбцу.
  data['Petukhovo1', missed_col[i]] <- 
    round(mean(data[, missed_col[i]], na.rm=T), digits=3)
}
rm(i)
```

Проверка того, как отработало заполнение средними:

```{r check_na_col_mean}
# Создаём вектор для подсчёта количества пропусков в столбце
missed_col <- vector(length=0)
# В цикле ищем столбцы с пропусками
for(i in 1:ncol(data)) {
  # Проверим наличие NA функцией суммы 
  # (TRUE при суммировании обрабатывается как единица); 
  # если сумма больше нуля (т.е., в столбце как минимум одно NA), 
  # добавляем номер столбца к вектору `missed_col`. 
  if(sum(is.na(data[i]))>0) missed_col <- append(missed_col, i)
}
rm(i)
# Проверка результата поиска: если длина `missed_col` ненулевая, 
if(length(missed_col) > 0) {
  # то выводим на экран столбцы с пропусками, 
  data[, missed_col]
  # а если она равна нулю, то 
} else {
  # выводим сообщение об отсутствии пропусков и удаляем `missed_col`. 
  cat('Пропусков нет')
  rm(missed_col)
}
```

## Функция для построения графов

Функция, основанная на `igraph`, потребуется для анализа связей между признаками. Она заточена на интерпретацию результатов анализа заданных главных компонент, и связи анализирует внутри них. Форма графа -- дерево, номер желаемых в качестве корня вершин определяется эмпирически (методом тыка).

Чтобы уменьшить число вершин графов, буду выводить их только для хорошо (*p* ≤ 0,05) коррелированных по Спирмену (два количественных), тесно связанных по Краскалу -- Уоллису (пара "количественный--качественный") или по хи-квадрат (два количественных) признаков.

В графах вершины, обозначающие характеристики популяций короеда, выделены красным цветом, категории состояния -- оранжевым, прочие характеристики древостоев -- серым.

Толщина рёбер графа соответствует силе связи между признаками (толще = сильнее), оцененной по величине уровня значимости связи (1 - *p*). Синий цвет означает отрицательную корреляцию, красный -- положительную корреляцию (связь между двумя количественными признаками) или сам факт наличия связи (качественный признак с количественным или другим качественным).

```{r function_for_graphs}
# Объявляем функцию с аргументами 
# `dim` – номер главной компоненты, для которой строится граф и 
# `root` – номер(а) корневой вершины (вершин) графа
plot_graph <- function(dim, root=1) {
  # `tmp` – временный фрейм, в который включаются те столбцы основного 
  # набора данных, которые являются основными для изучаемой компоненты. 
  tmp <- data[, colnames(data)[colnames(data) %in% rownames(pca_dim[[dim]])]] 
  # `tmp1` – матрица для записи результатов анализа связей. 
  tmp1 <- matrix(ncol=ncol(tmp), nrow=ncol(tmp)) 
  # Зададим имена строк и столбцов в `tmp1`
  colnames(tmp1) <- colnames(tmp)
  rownames(tmp1) <- colnames(tmp)
  
  # В цикле, пройдя по всем i столбцам `tmp`, заполним матрицу 
  # для записи результатов анализа связей
  for(i in 1:ncol(tmp)) { 
    # Во вложенном цикле пройдём по всем столбцам матрицы, 
    # проверяя их связь с i-м столбцом. 
    for(j in 1:ncol(tmp)) { 
      # Если оба признака количественные (mode=='numeric'), то
      if(mode(tmp[, i]) == 'numeric' & mode(tmp[, j]) == 'numeric') { 
        # выполним корреляционный анализ по Спирмену, 
        # занося результаты во временную переменную `tmp2`, и 
        tmp2 <- cor.test(tmp[, i], tmp[, j], method='spearman') 
        # если уровень значимости ≤ 0,05, то в ячейку [i, j] 
        # матрицы связей занесём величину коэффициента корреляции, 
        if(tmp2$p.value <= .05) tmp1[i, j] <- tmp2$estimate 
        # а если нет – то ноль. 
        else tmp1[i, j] <- 0
      }
      # Если оба признака качественные (mode=='character'), то
      if(mode(tmp[, i]) == 'character' & mode(tmp[, j]) == 'character') { 
        # оценим их связь по критерию хи-квадрат, 
        # занося результаты во временную переменную `tmp2`, и 
        tmp2 <- chisq.test(tmp[, i], tmp[, j])
        # если уровень значимости ≤ 0,05, то в ячейку [i, j] 
        # матрицы связей занесём разность единицы и уровня значимости, 
        if(tmp2$p.value <= .05) tmp1[i, j] <- 1 - tmp2$p.value 
        # а если нет – то ноль. 
        else tmp1[i, j] <- 0
      }
      # Если один признак количественный, а другой качественный, то
      if(mode(tmp[, i]) != mode(tmp[, j])) { 
        # качественный занесём во временную переменную `qual`, 
        # а количественный во временную переменную `quan`. 
        if(mode(tmp[, i]) == 'numeric') {
          quan <- tmp[, i]
          qual <- tmp[, j]
        } else {
          quan <- tmp[, j]
          qual <- tmp[, i]
        }
        # Во временную переменную `tmp2` занесём результаты оценки связи 
        # между ними по критерию Краскала – Уоллиса, и 
        tmp2 <- kruskal.test(quan, qual) 
        # если уровень значимости ≤ 0,05, то в ячейку [i, j] 
        # матрицы связей занесём разность единицы и уровня значимости, 
        if(tmp2$p.value <= .05) tmp1[i, j] <- 1 - tmp2$p.value 
        # а если нет – то ноль. 
        else tmp1[i, j] <- 0
      }
    }
    rm(j, quan, qual)
  }
  rm(i, tmp2)
  
  # После того, как матрица связей `tmp1` готова, то создадим на её основе
  # объект класса igraph, на основе которого далее построим граф связей.  
  g <- graph_from_adjacency_matrix(tmp1, mode='max', diag = F, weighted = T) 
  
  # Здесь зададим признаки, формирующие внешний вид графа: 
  # веса, от которых зависит толщина рёбер; 
  weights <- 10*(abs(E(g)$weight) - min(abs(E(g)$weight))) + .1 
  # направление связи, определяющее цвет рёбер; 
  dirs <- sapply(E(g)$weight, function(x) if(x<0) x<-'blue' else x<-'red')
  E(g)$weight <- abs(E(g)$weight) 
  # выделим группы признаков, отвечающие за цвета вершин, для чего 
  groups <- vector()
  # во вложенном цикле пройдём по всем признакам, включённым в граф, и 
  for(i in 1:length(V(g)$name)) { 
    # если признак описывает состояние древостоя, то 
    if(V(g)$name[i] %in% c('i', 'ii', 'iii', 'iv', 'v', 'vi')) { 
      # обозначим соответствующую вершину оранжевым, 
      groups <- append(groups, 'orange')
      next
    }
    # если он касается популяционных характеристик короеда, то красным,
    if(V(g)$name[i] %in% c('ia_density', 
                           'ia_density_par',	
                           'ia_gallery_length',	
                           'ia_trees_prop')) {
      groups <- append(groups, 'red')
      next
    } 
    # и если ни то, ни другое – серым. 
    groups <- append(groups, 'lightgray')
  }
  rm(i)
  
  # plot.igraph(g, 
  #             layout=layout_with_sugiyama(g, hgap=100), 
  #             edge.width=weights, 
  #             edge.color=dirs, 
  #             vertex.size=9, 
  #             vertex.label=1:length(V(g)$name), 
  #             vertex.color=groups, 
  #             vertex.label.cex=.55) 
  
  # Теперь собственно вывод графа, содержащегося в объекте `g`, на экран: 
  plot.igraph(g, 
              # зададим расположение вершин в виде дерева,
              layout=layout_as_tree(g, root=root), 
              # толщину рёбер передадим из переменной `weights`, 
              edge.width=weights, 
              # их цвета из `dirs`, 
              edge.color=dirs, 
              vertex.size=9, 
              vertex.label=1:length(V(g)$name), 
              # цвет вершин из `groups`. 
              vertex.color=groups, 
              vertex.label.cex=.55) 
  # Поскольку добавление названий признаков делает граф нечитаемым, 
  # вершины нумеруются, а в переменной `vertex_names` находятся их названия.
  vertex_names <- V(g)$name
  
  # Чтобы их увидеть, вернём `vertex_names` из функции 
  return(vertex_names)
}
```

```{r function_for_graph_names}
# Объявляем функцию для вывода имён вершин графа с аргументами 
# `n` – объект с именами, 
# `i` – номер главной компоненты. 
print_graph_names <- function(n, i) {
  # выведем на экран номер компоненты
  cat('Вершины графа для главной компоненты ', i, ':', sep='', fill=T) 
  # В цикле выведем имена вершин: 
  for(j in 1:length(n)) {
    # проверим чётность, и если имя на нечётном месте, то присоедним к нему 
    # номер, точку с запятой и выведем на экран, 
    if(j %/% 2 != j/2) cat(j, ': ', n[j], '; ', sep='') 
    # а если на чётном, то сделаем так же, но добавим к строке 
    # перенос на следующую строку (аргумент 'fill=T').
    else cat(j, ': ', n[j], '; ', sep='', fill=T)
    }
}
```

# Анализ главных компонент для смешанных данных

Задача -- выявить связи характеристик ослабления древостоя (категории состояния) и популяционных характеристик союзного короеда с предикторами. Суть этого метода в расчёте нескольких векторов (главных компонент), которых намного меньше, чем исходных признаков, и которые описывают данные с минимальными потерями информации. При этом исходные признаки более или менее тесно связаны с главными компонентами. Исследование структуры этих связей должно дать понимание того, как изучаемые признаки зависят друг от друга.

```{r pca}
# Собственно анализ главных компонент; результаты записываем в переменную `pca`
pca <- PCA(data, ncp=10, quali.sup=character_col, graph=F)
```

| Эти данные позволяют оценить, насколько найденные компоненты объясняют дисперсию реальных данных, и выбрать наиболее информативные из них для дальнейшей работы.

```{r pca_best_contributions}
# Выведем на экран собственные значения главных компонент
print(pca$eig)

# В списке `pca_dim` будут находиться данные о том, 
# какие признаки наиболее тесно связаны с каждой компонентой. 
pca_dim <- vector(length=ncol(pca$var$coord), mode='list')
# Имена элементов списка совпадают с номерами компонент
names(pca_dim) <- sapply(1:ncol(pca$var$coord), function(x) paste0('dim.', x))

# В цикле пройдём по каждой из компонент, данные о которых находятся 
# в объекте `pca` (см. чанк {r pca}). 
for(i in 1:ncol(pca$var$coord)) { 
  # Поскольку связь качественных и количественных переменных с компонентами 
  # описывается отдельно, то информацию о тесноте этих связей 
  # мы выделим в отдельные векторы: 
  # для количественных переменных (корреляция с i-й компонентой 
  # (выделяем только те признаки, для которых вклад (`contribution`) > 1) и 
  quanti_subset <- subset(pca$var$cor[, i], pca$var$contrib[, i] >= 1) 
  # для качественных переменных (eta2 – аналог коэффициента корреляции; 
  # (только те признаки, eta2 которых больше минимального коэффициента 
  # корреляции выделенных выше качественных признаков). 
  quali_subset <- 
    subset(pca$quali.sup$eta2[, i], 
           pca$quali.sup$eta2[, i] >= min(abs(quanti_subset))) 
  # При дальнейших преобразованиях имена признаков теряются, 
  # поэтому сохраним их в отдельный вектор, чтобы затем вернуть на место. 
  names <- c(names(quanti_subset), names(quali_subset))
  # Записываем в i-й элемент списка `pca_dim` объединённые данные
  # о связях количественных и качественных переменных с i-й компонентой. 
  pca_dim[[i]] <- data.frame(c(quanti_subset, quali_subset)) 
  # Для сортировки по модулю (т.е., по тесноте связи признаков и компоненты) 
  # добавляем столбец со значениями модулей. 
  pca_dim[[i]] <- cbind(pca_dim[[i]][, 1], abs(pca_dim[[i]][, 1])) 
  # Теперь нужно вернуть на место названия переменных в качестве имён строк
  row.names(pca_dim[[i]]) <- names
  # А сейчас сортируем по модулю (=по тесноте связи с компонентой)
  pca_dim[[i]] <- pca_dim[[i]][order(-pca_dim[[i]][, 2]), ]
  # Удаляем ненужный больше столбец с модулями
  pca_dim[[i]] <- pca_dim[[i]][, -2] 
  # Конвертируем матрицу во фрейм и присваиваем единственному столбцу имя
  pca_dim[[i]] <- data.frame(pca_dim[[i]])
  colnames(pca_dim[[i]]) <- 'correlation'
}
rm(i, quanti_subset, quali_subset, names)
```

| Далее работаем только с первыми пятью главными компонентами, каждая из которых объясняет более 10% дисперсии (суммарно почти 73%). Здесь отберём те признаки, которые связаны с ними наиболее тесно. Формальный критерий отбора -- вклад признака в компоненту (`contribution`), значение которого должно быть ≥ 1.

```{r vitality_and_beetle_checking}
# Здесь в цикле проверяем, какие признаки, характеризующие популяцию короеда
# и состояние древостоя с какими компонентами связаны. 
for(i in 1:5) { 
  # Если с i-й компонентой связаны категории состояния 
  # (проверяем через суммирование булевых данных), то
  if(sum(row.names(pca_dim[[i]]) %in% 
         c('i', 'ii', 'iii', 'iv', 'v', 'vi')) > 0) 
    # выводим список этих признаков на экран. 
    cat('Главная компонента ', i, ' связана с данными о состоянии: ',
        paste0(intersect(rownames(pca_dim[[i]]), 
                         c('i', 'ii', 'iii', 'iv', 'v', 'vi')), sep=', '),
        sep='', 
        fill=T)
  # Если с i-й компонентой связаны характеристики популяции короеда  
  # (проверяем через суммирование булевых данных), то
  if(sum(row.names(pca_dim[[i]]) %in% c('ia_density', 
                                         'ia_density_par',	
                                         'ia_gallery_length',	
                                         'ia_trees_prop')) > 0)
    # выводим список этих признаков на экран. 
    cat('Главная компонента ', i, ' связана с данными о популяции короеда: ',
        paste0(intersect(rownames(pca_dim[[i]]), c('ia_density', 
                                                   'ia_density_par',
                                                   'ia_gallery_length',	
                                                   'ia_trees_prop')), sep=', '), 
        sep='', 
        fill=T)
  cat(rep('-', 20), fill=T)
}
rm(i)
```

| Таким образом, самая тесная связь между состоянием древостоев и популяционными характеристиками короедов с одной стороны и прочими характеристиками с другой наблюдается во всех главной компонентах. 

Признаки, которые внесли наибольший вклад в первые пять главных компонент:

```{r components_interpretation, include=TRUE}
# В цикле выведем признаки, связаныне с каждой из первых пяти компонент
for(i in 1:5) {
  cat('Главная компонента ', i, ': ', 
      paste0(rownames(pca_dim[[i]])[-nrow(pca_dim[[i]])], sep=', '), 
      paste0(rownames(pca_dim[[i]])[nrow(pca_dim[[i]])], '.'), 
      sep='',  fill=T)
  cat(rep('-', 25), fill=T)
}
rm(i)
```

## Интерпретация главной компоненты 1

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_1, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных с первой компонентой, и 
n <- plot_graph(1, root=9)
# имена признаков, чтобы можно было этот граф прочитать. 
print_graph_names(n, 1)
rm(n)
```

**Главная компонента 1**:

- Основной вклад вносят характеристики почвенного дыхания (15--22) и тесно связанные с ними тип леса (8) и геоботанические индексы (10--12).

- Таксационные характеристики (1--7) описывают, с одной стороны, продуктивность древостоя, с другой его возраст.

- Переменные, описывающие зависимость прироста от погоды (13, 14), завязаны исключительно на тип леса; это следует интерпретировать как проявление зависимости влияния погоды на радиальный прирост от локальных условий.

- Переменные, описывающие химический состав почвы (24--31), связаны (напрямую или косвенно) преимущественно с объёмом стволовой древесины (6, 7) и характеризуют, таким образом, плодородие почвы.

- Затесавшаяся в эту компоненту доля сильно ослабленных деревьев (9) связана с влажностью (11) и трофностью (10, 12).

Таким образом, *главную компоненту 1 стоит интерпретировать как продуктивность местообитания*.

## Интерпретация главной компоненты 2

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_2, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных со второй компонентой, 
n <- plot_graph(2, root=4)
n <- plot_graph(2, root=6)
n <- plot_graph(2, root=7)
# имена признаков, чтобы можно было этот граф прочитать. 
print_graph_names(n, 2)
rm(n)
```

**Главная компонента 2**:

- Длина маточных ходов (4) положительно связана с содержанием общего азота (23) и содержанием калия в BEL (27). 

- Эти два признака, в свою очередь, более или менее тесно связаны друг с другом (положительно) и с содержанием азота, фосфора, калия (разнонаправленно). 

- Содержание калия в BEL положительно связано с поражённостью гнилями и отрицательно с чувствительности радиального прироста к температуре предыдущего сентября. 

- Тесно и отрицательн связаны друг с другом доля здоровых (6) и сильно ослабленных (7) деревьев кедра. 

- Отрицательно доля ослабленных деревьев связана с трофностью почвы (8, 9), направлением тренда радиального прироста до формирования очагов (10) и с содержанием общего азота (19). 

- Доля здоровых деревьев, в свою очередь, положительно связана с трофностью почвы, содержанием кальция и магния (28, 29), отрицательно с поражённостью гнилями (5). 

- В целом же большая часть связанных с этой компонентой переменных характеризует содержание в почве макроэлементов и, как интегральный показатель плодородия, рассчитанную по геоботаническим описаниям трофность. 

*Главная компонента 2 интерпретируется как содержание в почве макроэлементов.*

## Интерпретация главной компоненты 3 {#интерпретация-главной-компоненты-3}

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_3, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных с третьей компонентой, 
n <- plot_graph(3, root=4)
n <- plot_graph(3, root=5)
n <- plot_graph(3, root=6)
n <- plot_graph(3, root=7)
# с радиальным приростом (пригодится при интерпретации), и 
n <- plot_graph(3, root=9:10)
# имена признаков, чтобы можно было этот граф прочитать. 
cat('Вершины графа для главной компоненты ', 3, ':', sep='', fill=T)
for(j in 1:length(n)) {
  if(j %/% 2 != j/2) cat(j, ': ', n[j], '; ', sep='') 
  else cat(j, ': ', n[j], '; ', sep='', fill=T)
}
rm(j, n)
```

**Главная компонента 3**:

- Основную роль играют признаки, характеризующие обеспеченность азотом (24--26) и фосфором (21--23, 27, 28). Между собой эти элементы связаны отрицательно. Сюда же относим долготу (13), распределение N и P в которых имеет чёткую закономерность.

- Доля деревьев с поселениями короеда (4) положительно связана с долей сухостоя (6, 7) и участием кедра в составе (1), отрицательно с величиной радиального прироста (9, 10).

- На состояние древостоя (5--7) положительно влияет pH (16, 17), трофность (8) и рост содержания кальция (30).

Интерпретация *главной компоненты 3: кислотность почвы, обеспеченность азотом и фосфором.*

## Интерпретация главной компоненты 4 {#интерпретация-главной-компоненты-4}

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_4, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных с четвёртой компонентой, и 
n <- plot_graph(4, root=2:4)
# имена признаков, чтобы можно было этот граф прочитать. 
cat('Вершины графа для главной компоненты ', 4, ':', sep='', fill=T)
for(j in 1:length(n)) {
  if(j %/% 2 != j/2) cat(j, ': ', n[j], '; ', sep='') 
  else cat(j, ': ', n[j], '; ', sep='', fill=T)
}
rm(j, n)
```

**Главная компонента 4**:

- Много переменных, характеризующих состояние древостоя (6--9) и популяции короеда (2--4).

- Зависимость прироста от осадков мая и июля (12, 13) однозначно ведёт к повышению плотности поселения короеда (2, 3).

- Отрицательно на плотность поселения влияет содержание калия (29), положительно -- содержание гумуса (19) и органического углерода (22), возрастание разброса по высоте (1).

- Доля заселённых деревьев (4) положительно связана с долей отмирающих дереьвев и сухостоя (7--9). Отрицательно на неё влияет содержание магния (35, 37). 

- На долю сильно ослабленных деревьев (6) отрицательно влияет трофность (10). 

- Много переменных, характеризующих содержание углерода (17--22), катионов (29--37) и фосфора (24--28).

*Главная компонента 4* однозначно интерпретируется как *состояние древостоя и трофность*.

## Интерпретация главной компоненты 5 {#интерпретация-главной-компоненты-5}

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_5, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных с пятой компонентой, и 
n <- plot_graph(5, root=8:11)
n <- plot_graph(5, root=13:15)
# с радиальным приростом (пригодится при интерпретации), и 
n <- plot_graph(5, root=17:18)
# имена признаков, чтобы можно было этот граф прочитать. 
cat('Вершины графа для главной компоненты ', 5, ':', sep='', fill=T)
for(j in 1:length(n)) {
  if(j %/% 2 != j/2) cat(j, ': ', n[j], '; ', sep='') 
  else cat(j, ': ', n[j], '; ', sep='', fill=T)
}
rm(j, n)
```

**Главная компонента 5**: 

- Как и в случае компоненты 4, с этой компонентой связано много признаков, которые описывают популяцию короеда (8–11) и состояние древостоя (13--15). 

- Плотность поселения (8, 9) отрицательно связана с содержанием калия (28).

- Длина маточных ходов (10) положительно связана с содержанием калия (30).

- Доля заселённых деревьев (11) положительно связана с долей кедра в древостое (1) и объёмом его стволовой древесины (5), отрицательно с радиальным приростом (17, 18) и содержанием магния (32, 34).

- На долю усохших деревьев (15) влияет чувствительность прироста к температурам октября и осадкам мая предыдущего года (20, 21).

- Доля ослабленных деревьев (11) положительно связана с высотой древостоя (4). 

- Доля усыхающих деревьев отрицательно связана с радиальным приростом до формирования очагов (17) и содержанием катионов (31, 32, 34). 

Интерпретация *главной компоненты 5: влияние на состояние древостоя содержания катионов и таксационных характеристик*.

# Регрессионный анализ

Для построения модели использовали функцию `lm` пакета `base`. Оптимальные с точки зрения построения точной и неизбыточной модели предикторы подбирали, используя критрий Акаике (функция `stepAIC` пакета `MASS`). Наличие коллинеарных переменных в модели проверяли по VIF (коэффициент инфляции дисперсии) функцией `vif` из пакета `car`.

## Моделирование доли заселённых деревьев

Для моделирования доли заселённых деревьев используем:

-   содержание магния в AY `Mg_AY` ([Интерпретация главной компоненты 4](#интерпретация-главной-компоненты-4)),

-   доля кедра в древостое `ssp_prop` и объём его древесины `ssp_vol` ([Интерпретация главной компоненты 5](#интерпретация-главной-компоненты-5)).

Доля заселённых деревьев тесно связана с приростом. Но так как этот признак сильно меняется с возрастом, то напрямую его использовать не следует. В качестве прокси можно применить

-   обеспеченность фосфором `Ptot_BEL` ([Интерпретация главной компоненты 3](#интерпретация-главной-компоненты-3), [5](#интерпретрация главной компоненты-5)).

### Линейная модель

```{r ia_tree_prop_model_l, include=TRUE}
# Линейная модель
ia_tree_prop_model <- 
  lm(ia_trees_prop ~ ssp_prop + ssp_vol + Mg_AY + Ptot_BEL, data) 
# Отбор предикторов по критерию Акаике
ia_tree_prop_model <- stepAIC(ia_tree_prop_model, trace=0) 
# сводка по модели 
cat('Сводка по модели:', fill=T)
# summary(ia_tree_prop_model) 
knitr::kable(
  round(data.frame(summary(ia_tree_prop_model)$coefficients), digits=3),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(ia_tree_prop_model$residuals), 
      Q1 = quantile(ia_tree_prop_model$residuals, .25), 
      Median = quantile(ia_tree_prop_model$residuals, .5), 
      Q3 = quantile(ia_tree_prop_model$residuals, .75),
      Max. = max(ia_tree_prop_model$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
cat('VIF:', fill=T)
vif(ia_tree_prop_model) 
# Вывод графика реальных и предсказанных значений
plot(ia_tree_prop_model$model$ia_trees_prop, 
     ia_tree_prop_model$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
```

### Экспоненциальная модель

| Здесь попробуем улучшить модель, сделав её нелинейной.

```{r ia_tree_prop_model_exp, include=TRUE}
# Модель с экспонентой
ia_tree_prop_model_e <- lm(ia_trees_prop ~ ssp_prop + exp(Mg_AY), data) 
# Отбор предикторов по критерию Акаике
ia_tree_prop_model_e <- stepAIC(ia_tree_prop_model_e, trace=0) 
# сводка по модели 
cat('Сводка по модели:', fill=T)
knitr::kable(
  round(data.frame(summary(ia_tree_prop_model_e)$coefficients), digits=6),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(ia_tree_prop_model_e$residuals), 
      Q1 = quantile(ia_tree_prop_model_e$residuals, .25), 
      Median = quantile(ia_tree_prop_model_e$residuals, .5), 
      Q3 = quantile(ia_tree_prop_model_e$residuals, .75),
      Max. = max(ia_tree_prop_model_e$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
cat('VIF:', fill=T)
vif(ia_tree_prop_model_e) 
# Вывод графика реальных и предсказанных значений
plot(ia_tree_prop_model_e$model$ia_trees_prop, 
     ia_tree_prop_model_e$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
```

| Эта модель позволяет избавиться от ухода прогнозных значений в область отрицательных чисел, но за счёт хорошей потери в точности. Ввод дополнительных предикторов не помогает: проверено.

### Линейная модель с использованием косвенных связей

| Поскольку доля заселённых деревьев тесно связана с долей сухостоя, а та, в свою очередь, с pH, трофностью и содержанием кальция ([Интерпретация главной компоненты 3](#интерпретация-главной-компоненты-3)), есть смысл попробовать ввести эти характеристики (`ram_troph`, `pH_AY`, `Ca_AEL`) в модель.

```{r ia_tree_prop_model_indir, include=TRUE}
# Линейная модель
ia_tree_prop_model_indir <- 
  lm(ia_trees_prop ~ ssp_prop + ssp_vol + Mg_AY + Ptot_BEL + ram_troph + 
       pH_AY + Ca_AEL, 
     data) 
# Отбор предикторов по критерию Акаике
ia_tree_prop_model_indir <- stepAIC(ia_tree_prop_model_indir, 
                                    direction='backward', 
                                    trace=0) 
# сводка по модели 
cat('Сводка по модели:', fill=T)
knitr::kable(
  round(data.frame(summary(ia_tree_prop_model_indir)$coefficients), digits=3),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(ia_tree_prop_model_indir$residuals), 
      Q1 = quantile(ia_tree_prop_model_indir$residuals, .25), 
      Median = quantile(ia_tree_prop_model_indir$residuals, .5), 
      Q3 = quantile(ia_tree_prop_model_indir$residuals, .75),
      Max. = max(ia_tree_prop_model_indir$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
cat('VIF:', fill=T)
vif(ia_tree_prop_model_indir) 
# Вывод графика реальных и предсказанных значений
plot(ia_tree_prop_model_indir$model$ia_trees_prop, 
     ia_tree_prop_model_indir$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
```

| По-моему, это лучший результат.

## Моделирование плотности поселения *Ips amitinus*

Для моделирования плотности поселения короеда `ia_density` (она тесно связана ([Интерпретация главной компоненты 4](#интерпретация-главной-компоненты-4)) с плотностью родительского поколения `ia_density_par`, нет нужды делать две модели):

```{r plot_for_ia_density, include=TRUE}
# Вывод на экран графика для иллюстрации связи 
# между `ia_density` и `ia_density_prop`. 
plot(data$ia_density, data$ia_density_par, 
     xlab='Плотность поселения общая', 
     ylab='Родительское поколение')
```

-   разброс высот `ssp_height_sd`,

-   содержание органического углерода `Corg_BEL`, гумуса `hym_BEL` и калия `K_AY`.

```{r ia_density_model, include=TRUE}
# Линейная модель
ia_density_model <- 
  lm(ia_density ~ ssp_height_sd + Corg_BEL + hum_BEL + K_AY, data)
# Отбор предикторов по критерию Акаике
ia_density_model <- stepAIC(ia_density_model, trace=0)
# сводка по модели 
cat('Сводка по модели:', fill=T)
knitr::kable(
  round(data.frame(summary(ia_density_model)$coefficients), digits=3),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(ia_density_model$residuals), 
      Q1 = quantile(ia_density_model$residuals, .25), 
      Median = quantile(ia_density_model$residuals, .5), 
      Q3 = quantile(ia_density_model$residuals, .75),
      Max. = max(ia_density_model$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
cat('VIF:', fill=T)
vif(ia_density_model)
# Вывод графика реальных и предсказанных значений
plot(ia_density_model$model$ia_density, 
     ia_density_model$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
```

# Дополнительный материал

## Расшифровка использованных признаков {#расшифровка-использованных-признаков}

| Код признака| Расшифровка | Тип данных |
|-|-|-|
| ssp_prop | Доля кедра в древостое | количественный |
| ssp_age | Возраст кедра | количественный |
| ssp_age_sd | Возраста кедра, стандартное отклонение | количественный |
| ssp_diam | Диаметр кедра | количественный |
| ssp_diam_sd | Диаметр кедра, стандартное отклонение | количественный |
| ssp_height | Высота кедра | количественный |
| ssp_height_sd | Высота кедра, стандартное отклонение | количественный |
| ssp_vol | Объём стволовой древесины кедра | количественный |
| overall_vol | Объём стволовой древесины всех пород | количественный |
| density | Полнота | количественный |
| forest_type | Тип леса | номинальный |
| ia_density | Плотность поселения союзного короеда, общая | количественный |
| ia_density_par | Плотность поселения союзного короеда, родительское поколение | количественный |
| ia_gallery_length | Длина маточных ходов | количественный |
| ia_trees_prop | Доля деревьев, заселённых союзным короедом | количественный |
| rot | Доля гнили в стволах кедра по объёму | количественный |
| Pschw | Наличие деревьев, поражённых трутовиком Швейница | булев |
| Arm | То же, опёнком  | булев |
| Fros | То же, трутовиком розовым  | булев |
| Fpin | То же, сосновой губкой | булев |
| Hann  | То же, корневой губкой  | булев |
| Phchrys | То же, еловой губкой  | булев |
| Lshulph | То же, трутовиком серно-жёлтым  | булев |
| Tab | То же, трихаптумом еловым | булев |
| Gluc | То же, трутовиком лакированным | булев |
| Gsep | То же, трутовиком заборным | булев |
| br  | То же, ржавчинным раком | булев |
| Nec | То же, нектриевым раком | булев |
| necr | То же, некрозами | булев |
| i | Доля здоровых деревьев | количественный |
| ii | То же, ослабленных | количественный |
| iii | То же, сильно ослабленных | количественный |
| iv | То же, усыхающих | количественный |
| v | То же, свежего сухостоя | количественный |
| vi | То же, старого сухостоя | количественный |
| ram_hum | Балл увлажнённости по Раменскому  | количественный |
| ram_troph | Балл трофности по Раменскому  | количественный |
| tsa_hum | Балл увлажнённости по Цаценкину | количественный |
| tsa_troph | Балл трофности по Цаценкину | количественный |
| rw_before | Средняя ширина годичного кольца до начала инвазии (2001--2010 гг.)  | количественный |
| rw_after  | То же, после начала инвазии (2011--2020 гг.)  | количественный |
| trend_before | Линейный коэффициент уравнения прироста до 2010 г. | количественный |
| trend_after | То же, после 2010 г.  | количественный |
| temp_whole_prev_may | Наличие реакции радиального прироста на температуры мая предыдущего сезона за весь период наблюдений | номинальный |
| temp_whole_prev_aug | То же, для августа  | номинальный |
| temp_whole_prev_sep | То же, для сентября | номинальный |
| temp_whole_prev_oct | То же, для октября  | номинальный |
| temp_whole_prev_nov | То же, для ноября | номинальный |
| temp_whole_curr_jan | Наличие реакции радиального прироста на температуры января текущего сезона за весь период наблюдений | номинальный |
| temp_whole_curr_mar | То же, для марта | номинальный |
| temp_whole_curr_may | То же, для мая | номинальный |
| temp_whole_curr_jun | То же, для июня | номинальный |
| prec_whole_prev_feb | Наличие реакции радиального прироста на осадки февраля предыдущего сезона за весь период наблюдений | номинальный |
| prec_whole_prev_apr | То же, для марта | номинальный |
| prec_whole_prev_may | То же, для мая | номинальный |
| prec_whole_prev_jun | То же, для июня | номинальный |
| prec_whole_prev_jul | То же, для июля | номинальный |
| prec_whole_prev_aug | То же, для августа | номинальный |
| prec_whole_prev_nov | То же, для ноября | номинальный |
| prec_whole_curr_jan | Наличие реакции радиального прироста на осадки января текущего сезона за весь период наблюдений | номинальный |
| prec_whole_curr_feb | То же для февраля | номинальный |
| prec_whole_curr_may | То же, для мая | номинальный |
| prec_whole_curr_jun | То же, для июня | номинальный |
| prec_whole_curr_jul | То же, для июля | номинальный |
| prec_whole_curr_sep | То же, для сентября | номинальный |
| lat | Широта  | количественный |
| lon | Долгота | количественный |
| X0h | Субстрат-индуцированное дыхание, 0 часов | количественный |
| X4h | То же, 4 часа | количественный |
| X8h | То же, 8 часов | количественный |
| X18h | То же, 18 часов | количественный |
| X30h | То же, 30 часов | количественный |
| X48h | То же, 48 часов | количественный |
| X72h | То же, 72 часа | количественный |
| X102h | То же, 102 часа | количественный |
| Rr | Respiration rate (?) | количественный |
| depth_AY | Мощность горизонта AY | количественный |
| depth_AEL | То же, AEL | количественный |
| depth_BEL | То же, BEL | количественный |
| Corg_AY | Содержание органического углерода в горизонте AY | количественный |
| Corg_AEL | То же, AEL | количественный |
| Corg_BEL | То же, BEL | количественный |
| hum_AY | Содержание гумуса в горизонте AY | количественный |
| hum_AEL | То же, AEL | количественный |
| hum_BEL | То же, BEL | количественный |
| Ntot_AY | Содержание общего азота в горизонте AY | количественный |
| Ntot_AEL | То же, AEL | количественный |
| Ntot_BEL | То же, BEL | количественный |
| Ptot_AY | Содержание общего фосфора в горизонте AY | количественный |
| Ptot_AEL | То же, AEL | количественный |
| Ptot_BEL | То же, BEL | количественный |
| NO2tot_AY | Содержание NO~2~ в горизонте AY | количественный |
| NO2tot_AEL | То же, AEL | количественный |
| NO2tot_BEL | То же, BEL | количественный |
| P2O5_AY | Содержание P~2~O~5~ в горизонте AY | количественный |
| P2O5_AEL | То же, AEL | количественный |
| P2O5_BEL | То же, BEL | количественный |
| K_AY | Содержание калия в горизонте AY | количественный |
| K_AEL | То же, AEL | количественный |
| K_BEL | То же, BEL | количественный |
| Ca_AY | Содержание кальция в горизонте AY | количественный |
| Ca_AEL | То же, AEL | количественный |
| Ca_BEL | То же, BEL | количественный |
| Mg_AY | Содержание магния в горизонте AY | количественный |
| Mg_AEL | То же, AEL | количественный |
| Mg_BEL | То же, BEL | количественный |
| pH_AY | Кислотность горизонта AY | количественный |
| pH_AEL | То же, AEL | количественный |
| pH_BEL | То же, BEL | количественный |

## Графический анализ: связи между характеристиками древостоев

Пары признаков, для которых готовили графики, выбирали как в [Графический анализ: графы связей](#графический-анализ-графы-связей).

```{r graphical_analysis_of_relations, include=TRUE, warning=FALSE}
for(i in 1:(ncol(data) - 1)) {
  j <- i + 1
  while(j <= ncol(data)) { 
    if(mode(data[, i]) == 'numeric' & mode(data[, j]) == 'numeric') {
      tmp <- cor.test(data[, i], data[, j], method='spearman')
      if(tmp$p.value <= .05) plot(data[, i], data[, j], 
                                  xlab=colnames(data)[i], 
                                  ylab=colnames(data)[j])
    }
    if(mode(data[, i]) == 'character' & mode(data[, j]) == 'character') {
      tmp <- chisq.test(data[, i], data[, j])
      if(tmp$p.value <= .05) barplot(table(data[, i], data[, j]), 
                                     xlab=colnames(data)[j], 
                                     ylab=colnames(data)[i], 
                                     legend=T)
    }
    if(mode(data[, i]) != mode(data[, j])) {
      if(mode(data[, i]) == 'numeric') {
        quan <- data[, i]
        qual <- data[, j]
        name_quan <- colnames(data)[i]
        name_qual <- colnames(data)[j]
      } else {
        quan <- data[, j]
        qual <- data[, i]
        name_quan <- colnames(data)[j]
        name_qual <- colnames(data)[i]
      }
        tmp <- kruskal.test(quan, qual)
        if(tmp$p.value <= .05) boxplot(quan ~ qual, 
                                       xlab=name_qual, 
                                       ylab=name_quan)
    }
    j <- j + 1
  }
  rm(j, tmp, quan, qual, name_quan, name_qual)
}
rm(i)
```
