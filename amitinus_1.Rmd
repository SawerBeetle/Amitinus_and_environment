---
title: "Союзный короед в припоселковых кедровниках"
output:
  word_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE, echo = FALSE}
knitr::opts_chunk$set(include=FALSE, echo = FALSE, warnings=FALSE, message=FALSE)
```

```{r clear_env}
rm(list=ls())
```

# Введение

Обработка материалов, собранных летом 2021 года в припоселковых кедровниках окрестностей Томска.

**Цель**: установить связи состояния древостоя и популяционных характеристик союзного короеда *Ips amitinus* с таксационными характеристиками древостоя, болезнями деревьев, свойствами почвы (богатство, увлажнённость и пр. по экологическим шкалам; pH, содержание отдельных веществ; дыхание почвы), характеристиками радиального прироста, чувствительностью к погодным условиям.

**Задачи**:

-   выделить факторы, наиболее тесно связанные с характеристиками популяции и состоянием древостоя в очагах союзного короеда;
-   описать эти зависимости аналитически.

# Подготовка к работе

## Загрузка библиотек

Для предподготовки `mice`, для анализа главных компонент `FactoMineR`, для создания линейной модели `car` и `MASS`, для исследования структуры связей между переменными `igraph`.

```{r libraries}
library('mice')               # mice
library('FactoMineR')         # PCA 
library('igraph')             # plot.igraph, graph_from_adjacency_matrix, E, V
library('car')                # vif
library('MASS')               # stepAIC
```

## Загрузка и подготовка данных

| Предварительный этап работ показал, что Лучаново лучше выбросить, так как оно сильно искажает результаты. Видимо, там сказалось влияние мощного внешнего фактора -- дефолиации сибирским шелкопрядом, которое маскирует всё остальное. 

| Также нет смысла сохранять данные о корреляциях прироста с погодой для отдельных временных промежутков: интерпретации они, как показала предыдущая итерация, не помогают. Напротив, занимая место и отвлекая внимание, они препятствуют пониманию сложившейся картины. 

| Удалим и данные о поражении *Fomes fomentarius* (поражает лиственные породы) и ведьмиными мётлами (ржавчинный рак пихты, только на пихте). 

```{r data}
# загрузка данных
data <- read.csv2('C:/Users/user/YandexDisk/Важные документы/Исходные данные для статей/Союзный/data.csv', row.names = 1)
# удаление Лучаново
data <- data[rownames(data) != 'Luchanovo', ]
# Удаление данных о корреляциях с погодой на отдельных временных промежутках, 
# поражённости настоящим трутовиком и ржавчинным раком.
data <- data[, -c(21, 28, 68:119)]
# удаление данных о почвенных характеристиках
data <- data[, -c(68:109)]
# вывод на экран сообщения об объёме и составе данных
cat('Всего рассмотрим ', nrow(data), ' пробных площадей и ', ncol(data), 
    ' признаков.', fill=T, sep='')
cat(rep('-', 25), fill=T, sep='')
for(i in 1:ncol(data)) {
  cat(i, '. ', colnames(data)[i], fill=T, sep='')
}
rm(i)
```

```{r character_data}
# Создадим вектор с названиями столбцов, где данные представлены 
# в текстовом формате (для удобства дальнейшей работы):
# сначала собственно создание вектора, 
character_col <- vector(mode='integer', length=0)
# а в цикле – его заполнение
for(i in 1:ncol(data)) { 
  # если mode(df$col)=='character', то добавляем номер столбца в `character_col`
  if(is.character(data[, i])) character_col <- append(character_col, i)
}
rm(i)
# выведем названия столбцов с текстовыми данными
for(i in 1:length(character_col)) {
  cat(character_col[i], '. ', colnames(data)[character_col[i]], fill=T, sep='')
}
rm(i)
```

Заполним имеющиеся пропуски в данных (почва по Петухово 1 и что-то там по почве в Аркашёво) с помощью функции `mice` (метод predictice mean matching).

```{r impute_by_mice, warning=FALSE}
# Рассчитаем значения пропущенных данных
tmp <- mice(data, method='pmm', printFlag=F, seed=1980)
# Заполним пропуски
data <- complete(tmp)
# Удалим результаты работы функций `mice`, чтобы не мешали
rm(tmp) 
```

Проверка того, как отработал алгоритм `mice`.

```{r check_na_col_mice}
# Создаём вектор для подсчёта количества пропусков в столбце
missed_col <- vector(length=0)
# В цикле ищем столбцы с пропусками
for(i in 1:ncol(data)) {
  # Проверим наличие NA функцией суммы 
  # (TRUE при суммировании обрабатывается как единица); 
  # если сумма больше нуля (т.е., в столбце как минимум одно NA), 
  # добавляем номер столбца к вектору `missed_col`. 
  if(sum(is.na(data[i]))>0) missed_col <- append(missed_col, i)
}
rm(i)
# Проверка результата поиска: если длина `missed_col` ненулевая, 
if(length(missed_col) > 0) {
  # то выводим на экран столбцы с пропусками, 
  data[, missed_col]
  # а если она равна нулю, то 
} else {
  # выводим сообщение об отсутствии пропусков и удаляем `missed_col`. 
  cat('Пропусков нет.')
  rm(missed_col)
}
```

## Функция для построения графов

Функция, основанная на `igraph`, потребуется для анализа связей между признаками. Она заточена на интерпретацию результатов анализа заданных главных компонент, и связи анализирует внутри них. Форма графа -- дерево, номер желаемых в качестве корня вершин определяется эмпирически (методом тыка).

Чтобы уменьшить число вершин графов, буду выводить их только для хорошо (*p* ≤ 0,05) коррелированных по Спирмену (два количественных), тесно связанных по Краскалу -- Уоллису (пара "количественный--качественный") или по хи-квадрат (два количественных) признаков.

В графах вершины, обозначающие характеристики популяций короеда, выделены красным цветом, категории состояния -- оранжевым, прочие характеристики древостоев -- серым.

Толщина рёбер графа соответствует силе связи между признаками (толще = сильнее), оцененной по величине уровня значимости связи (1 - *p*). Синий цвет означает отрицательную корреляцию, красный -- положительную корреляцию (связь между двумя количественными признаками) или сам факт наличия связи (качественный признак с количественным или другим качественным).

```{r function_for_graphs}
# Объявляем функцию с аргументами 
# `dim` – номер главной компоненты, для которой строится граф и 
# `root` – номер(а) корневой вершины (вершин) графа
plot_graph <- function(dim, root=1) {
  # `tmp` – временный фрейм, в который включаются те столбцы основного 
  # набора данных, которые являются основными для изучаемой компоненты. 
  tmp <- data[, colnames(data)[colnames(data) %in% rownames(pca_dim[[dim]])]] 
  # `tmp1` – матрица для записи результатов анализа связей. 
  tmp1 <- matrix(ncol=ncol(tmp), nrow=ncol(tmp)) 
  # Зададим имена строк и столбцов в `tmp1`
  colnames(tmp1) <- colnames(tmp)
  rownames(tmp1) <- colnames(tmp)
  
  # В цикле, пройдя по всем i столбцам `tmp`, заполним матрицу 
  # для записи результатов анализа связей
  for(i in 1:ncol(tmp)) { 
    # Во вложенном цикле пройдём по всем столбцам матрицы, 
    # проверяя их связь с i-м столбцом. 
    for(j in 1:ncol(tmp)) { 
      # Если оба признака количественные (mode=='numeric'), то
      if(mode(tmp[, i]) == 'numeric' & mode(tmp[, j]) == 'numeric') { 
        # выполним корреляционный анализ по Спирмену, 
        # занося результаты во временную переменную `tmp2`, и 
        tmp2 <- cor.test(tmp[, i], tmp[, j], method='spearman') 
        # если уровень значимости ≤ 0,05, то в ячейку [i, j] 
        # матрицы связей занесём величину коэффициента корреляции, 
        if(tmp2$p.value <= .05) tmp1[i, j] <- tmp2$estimate 
        # а если нет – то ноль. 
        else tmp1[i, j] <- 0
      }
      # Если оба признака качественные (mode=='character'), то
      if(mode(tmp[, i]) == 'character' & mode(tmp[, j]) == 'character') { 
        # оценим их связь по критерию хи-квадрат, 
        # занося результаты во временную переменную `tmp2`, и 
        tmp2 <- chisq.test(tmp[, i], tmp[, j])
        # если уровень значимости ≤ 0,05, то в ячейку [i, j] 
        # матрицы связей занесём разность единицы и уровня значимости, 
        if(tmp2$p.value <= .05) tmp1[i, j] <- 1 - tmp2$p.value 
        # а если нет – то ноль. 
        else tmp1[i, j] <- 0
      }
      # Если один признак количественный, а другой качественный, то
      if(mode(tmp[, i]) != mode(tmp[, j])) { 
        # качественный занесём во временную переменную `qual`, 
        # а количественный во временную переменную `quan`. 
        if(mode(tmp[, i]) == 'numeric') {
          quan <- tmp[, i]
          qual <- tmp[, j]
        } else {
          quan <- tmp[, j]
          qual <- tmp[, i]
        }
        # Во временную переменную `tmp2` занесём результаты оценки связи 
        # между ними по критерию Краскала – Уоллиса, и 
        tmp2 <- kruskal.test(quan, qual) 
        # если уровень значимости ≤ 0,05, то в ячейку [i, j] 
        # матрицы связей занесём разность единицы и уровня значимости, 
        if(tmp2$p.value <= .05) tmp1[i, j] <- 1 - tmp2$p.value 
        # а если нет – то ноль. 
        else tmp1[i, j] <- 0
      }
    }
    rm(j, quan, qual)
  }
  rm(i, tmp2)
  
  # После того, как матрица связей `tmp1` готова, то создадим на её основе
  # объект класса igraph, на основе которого далее построим граф связей.  
  g <- graph_from_adjacency_matrix(tmp1, mode='max', diag = F, weighted = T) 
  
  # Здесь зададим признаки, формирующие внешний вид графа: 
  # веса, от которых зависит толщина рёбер; 
  weights <- 10*(abs(E(g)$weight) - min(abs(E(g)$weight))) + .1 
  # направление связи, определяющее цвет рёбер; 
  dirs <- sapply(E(g)$weight, function(x) if(x<0) x<-'blue' else x<-'red')
  E(g)$weight <- abs(E(g)$weight) 
  # выделим группы признаков, отвечающие за цвета вершин, для чего 
  groups <- vector()
  # во вложенном цикле пройдём по всем признакам, включённым в граф, и 
  for(i in 1:length(V(g)$name)) { 
    # если признак описывает состояние древостоя, то 
    if(V(g)$name[i] %in% c('i', 'ii', 'iii', 'iv', 'v', 'vi')) { 
      # обозначим соответствующую вершину оранжевым, 
      groups <- append(groups, 'orange')
      next
    }
    # если он касается популяционных характеристик короеда, то красным,
    if(V(g)$name[i] %in% c('ia_density', 
                           'ia_density_par',	
                           'ia_gallery_length',	
                           'ia_trees_prop')) {
      groups <- append(groups, 'red')
      next
    } 
    # и если ни то, ни другое – серым. 
    groups <- append(groups, 'lightgray')
  }
  rm(i)
  
  # plot.igraph(g, 
  #             layout=layout_with_sugiyama(g, hgap=100), 
  #             edge.width=weights, 
  #             edge.color=dirs, 
  #             vertex.size=9, 
  #             vertex.label=1:length(V(g)$name), 
  #             vertex.color=groups, 
  #             vertex.label.cex=.55) 
  
  # Теперь собственно вывод графа, содержащегося в объекте `g`, на экран: 
  plot.igraph(g, 
              # зададим расположение вершин в виде дерева,
              layout=layout_as_tree(g, root=root), 
              # толщину рёбер передадим из переменной `weights`, 
              edge.width=weights, 
              # их цвета из `dirs`, 
              edge.color=dirs, 
              vertex.size=9, 
              vertex.label=1:length(V(g)$name), 
              # цвет вершин из `groups`. 
              vertex.color=groups, 
              vertex.label.cex=.55) 
  # Поскольку добавление названий признаков делает граф нечитаемым, 
  # вершины нумеруются, а в переменной `vertex_names` находятся их названия.
  vertex_names <- V(g)$name
  
  # Чтобы их увидеть, вернём `vertex_names` из функции 
  return(vertex_names)
}
```

```{r function_for_graph_names}
# Объявляем функцию для вывода имён вершин графа с аргументами 
# `n` – объект с именами, 
# `i` – номер главной компоненты. 
print_graph_names <- function(n, i) {
  # выведем на экран номер компоненты
  cat('Вершины графа для главной компоненты ', i, ':', sep='', fill=T) 
  # В цикле выведем имена вершин: 
  for(j in 1:length(n)) {
    # проверим чётность, и если имя на нечётном месте, то присоедним к нему 
    # номер, точку с запятой и выведем на экран, 
    if(j %/% 2 != j/2) cat(j, ': ', n[j], '; ', sep='') 
    # а если на чётном, то сделаем так же, но добавим к строке 
    # перенос на следующую строку (аргумент 'fill=T').
    else cat(j, ': ', n[j], '; ', sep='', fill=T)
    }
}
```

# Анализ главных компонент для смешанных данных

Задача -- выявить связи характеристик ослабления древостоя (категории состояния) и популяционных характеристик союзного короеда с предикторами. Суть этого метода в расчёте нескольких векторов (главных компонент), которых намного меньше, чем исходных признаков, и которые описывают данные с минимальными потерями информации. При этом исходные признаки более или менее тесно связаны с главными компонентами. Исследование структуры этих связей должно дать понимание того, как изучаемые признаки зависят друг от друга.

```{r pca}
# Собственно анализ главных компонент; результаты записываем в переменную `pca`
pca <- PCA(data, ncp=10, quali.sup=character_col, graph=F)
```

| Эти данные позволяют оценить, насколько найденные компоненты объясняют дисперсию реальных данных, и выбрать наиболее информативные из них для дальнейшей работы.

```{r pca_best_contributions}
# Выведем на экран собственные значения главных компонент
print(pca$eig)

# В списке `pca_dim` будут находиться данные о том, 
# какие признаки наиболее тесно связаны с каждой компонентой. 
pca_dim <- vector(length=ncol(pca$var$coord), mode='list')
# Имена элементов списка совпадают с номерами компонент
names(pca_dim) <- sapply(1:ncol(pca$var$coord), function(x) paste0('dim.', x))

# В цикле пройдём по каждой из компонент, данные о которых находятся 
# в объекте `pca` (см. чанк {r pca}). 
for(i in 1:ncol(pca$var$coord)) { 
  # Поскольку связь качественных и количественных переменных с компонентами 
  # описывается отдельно, то информацию о тесноте этих связей 
  # мы выделим в отдельные векторы: 
  # для количественных переменных (корреляция с i-й компонентой 
  # (выделяем только те признаки, для которых вклад (`contribution`) > ~~1~~3) и 
  quanti_subset <- subset(
    pca$var$cor[, i], 
    pca$var$contrib[, i] > median(pca$var$contrib[, i])
  ) 
  # для качественных переменных (eta2 – аналог коэффициента корреляции; 
  # (только те признаки, eta2 которых больше минимального коэффициента 
  # корреляции выделенных выше качественных признаков). 
  quali_subset <- 
    subset(pca$quali.sup$eta2[, i], 
           pca$quali.sup$eta2[, i] >= min(abs(quanti_subset))) 
  # При дальнейших преобразованиях имена признаков теряются, 
  # поэтому сохраним их в отдельный вектор, чтобы затем вернуть на место. 
  names <- c(names(quanti_subset), names(quali_subset))
  # Записываем в i-й элемент списка `pca_dim` объединённые данные
  # о связях количественных и качественных переменных с i-й компонентой. 
  pca_dim[[i]] <- data.frame(c(quanti_subset, quali_subset)) 
  # Для сортировки по модулю (т.е., по тесноте связи признаков и компоненты) 
  # добавляем столбец со значениями модулей. 
  pca_dim[[i]] <- cbind(pca_dim[[i]][, 1], abs(pca_dim[[i]][, 1])) 
  # Теперь нужно вернуть на место названия переменных в качестве имён строк
  row.names(pca_dim[[i]]) <- names
  # А сейчас сортируем по модулю (=по тесноте связи с компонентой)
  pca_dim[[i]] <- pca_dim[[i]][order(-pca_dim[[i]][, 2]), ]
  # Удаляем ненужный больше столбец с модулями
  pca_dim[[i]] <- pca_dim[[i]][, -2] 
  # Конвертируем матрицу во фрейм и присваиваем единственному столбцу имя
  pca_dim[[i]] <- data.frame(pca_dim[[i]])
  colnames(pca_dim[[i]]) <- 'correlation'
}
rm(i, quanti_subset, quali_subset, names)
```

| Далее работаем только с первыми пятью главными компонентами, каждая из которых объясняет более 10% дисперсии (суммарно почти ~~73~~80%). Здесь отберём те признаки, которые связаны с ними наиболее тесно. Формальный критерий отбора -- вклад признака в компоненту (`contribution`), значение которого должно быть ~~≥1~~ выше медианного значения.

```{r vitality_and_beetle_checking}
# Здесь в цикле проверяем, какие признаки, характеризующие популяцию короеда
# и состояние древостоя с какими компонентами связаны. 
for(i in 1:5) { 
  # Если с i-й компонентой связаны категории состояния 
  # (проверяем через суммирование булевых данных), то
  if(sum(row.names(pca_dim[[i]]) %in% 
         c('i', 'ii', 'iii', 'iv', 'v', 'vi')) > 0) 
    # выводим список этих признаков на экран. 
    cat('Главная компонента ', i, ' связана с данными о состоянии: ',
        paste0(intersect(rownames(pca_dim[[i]]), 
                         c('i', 'ii', 'iii', 'iv', 'v', 'vi')), sep=', '),
        sep='', 
        fill=T)
  # Если с i-й компонентой связаны характеристики популяции короеда  
  # (проверяем через суммирование булевых данных), то
  if(sum(row.names(pca_dim[[i]]) %in% c('ia_density', 
                                         'ia_density_par',	
                                         'ia_gallery_length',	
                                         'ia_trees_prop')) > 0)
    # выводим список этих признаков на экран. 
    cat('Главная компонента ', i, ' связана с данными о популяции короеда: ',
        paste0(intersect(rownames(pca_dim[[i]]), c('ia_density', 
                                                   'ia_density_par',
                                                   'ia_gallery_length',	
                                                   'ia_trees_prop')), sep=', '), 
        sep='', 
        fill=T)
  cat(rep('-', 20), fill=T)
}
rm(i)
```

| После удаления из обработке данных о почве смысл работы с компонентами 4–5 пропадает. Далее сосредоточимся на первых трёх из них, которые вполне характеризуют как виталитетный спектр древостоев, так и популяционные характеристики союзного короеда.

| ~~Таким образом, самая тесная связь между состоянием древостоев и популяционными характеристиками короедов с одной стороны и прочими характеристиками с другой наблюдается во всех главной компонентах.~~ 

Признаки, которые внесли наибольший вклад в первые ~~пять~~ три главных компоненты:

```{r components_interpretation, include=TRUE}
# В цикле выведем признаки, связаныне с каждой из первых пяти компонент
# for(i in 1:5) {
for(i in 1:3) {
  cat('Главная компонента ', i, ': ', 
      paste0(rownames(pca_dim[[i]])[-nrow(pca_dim[[i]])], sep=', '), 
      paste0(rownames(pca_dim[[i]])[nrow(pca_dim[[i]])], '.'), 
      sep='',  fill=T)
  cat(rep('-', 25), fill=T)
}
rm(i)
```

## Интерпретация главной компоненты 1

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_1, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных с первой компонентой, и 
n <- plot_graph(1, root=7)
n <- plot_graph(1, root=8)
# имена признаков, чтобы можно было этот граф прочитать. 
print_graph_names(n, 1)
rm(n)
```

**Главная компонента 1**:

- Признаки, характеризующие популяцию короеда, находятся в этой компоненте особняком, не давая возможностей для интерпретации. 
- Доля здоровых деревьев (7) отрицательно связана со степенью поражённости гнилями (6) и увлажнённостью почвы (9, 11), положительно – с богатством почвы (10, 12). Связь её с долей сильно ослабленных деревьев (8) отрицательна. 
- Доля сильно ослабленных деревьев связана с теми же характеристиками, что (7), но направление связи меняется. Кроме того, она отрицательна связана с трендом радиального прироста до начала инвазии.

Таким образом, *главную компоненту 1 стоит интерпретировать как благоприятность местообитания для кедра*.

## Интерпретация главной компоненты 2

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_2, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных со второй компонентой, 
n <- plot_graph(2, root=6)
n <- plot_graph(2, root=7)
n <- plot_graph(2, root=8)
n <- plot_graph(2, root=9)
n <- plot_graph(2, root=10)
# имена признаков, чтобы можно было этот граф прочитать. 
print_graph_names(n, 2)
rm(n)
```

**Главная компонента 2**:

- Доля заселённых союзным короедом деревьев (6) положительно связана с его участием в древостое и объёмом стволовой древесины, а также с долей сухостоя (9, 10). Предсказуемо отрицательна связь с шириной годичного кольца (13, 14). 
- Доля усыхающих и сухостойных  деревьев (8–10) так или иначе связаны друг с другом и с долей ослабленных деревьев (7). Их корреляция с радиальным приростом (13, 14) отрицательна. 

*Главная компонента 2 интерпретируется как участие кедра в древостое.*

## Интерпретация главной компоненты 3 {#интерпретация-главной-компоненты-3}

[Расшифровка использованных признаков](#расшифровка-использованных-признаков).

```{r plot_graphs_3, fig.width=6, fig.height=6, include=TRUE, warning=FALSE}
# Выведем граф для признаков, связанных с третьей компонентой,
n <- plot_graph(3, root=7)
n <- plot_graph(3, root=10)
n <- plot_graph(3, root=11)
n <- plot_graph(3, root=12)
# с радиальным приростом (пригодится при интерпретации), и
# n <- plot_graph(3, root=9:10)
# имена признаков, чтобы можно было этот граф прочитать.
cat('Вершины графа для главной компоненты ', 3, ':', sep='', fill=T)
for(j in 1:length(n)) {
  if(j %/% 2 != j/2) cat(j, ': ', n[j], '; ', sep='')
  else cat(j, ': ', n[j], '; ', sep='', fill=T)
}
rm(j, n)
```

**Главная компонента 3**:

- Из закономерностей, не отмеченных ранее, следует указать лишь положительную корреляцию доли ослабленных деревьев (10) с высотой древостоя (4).

Содержательная интерпретация *главной компоненты 3* с точки зрения цели работы смысла не имеет. 

# Регрессионный анализ

Для построения модели использовали функцию `lm` пакета `base`. Оптимальные с точки зрения построения точной и неизбыточной модели предикторы подбирали, используя критрий Акаике (функция `stepAIC` пакета `MASS`). Наличие коллинеарных переменных в модели проверяли по VIF (коэффициент инфляции дисперсии) функцией `vif` из пакета `car`.

## Моделирование доли заселённых деревьев

Для моделирования доли заселённых деревьев используем долю кедра в древостое `ssp_prop` и объём его древесины `ssp_vol` ([Интерпретация главной компоненты 2](#интерпретация-главной-компоненты-2)).

```{r ia_tree_prop_model_l, include=TRUE}
# Линейная модель
ia_tree_prop_model <- lm(ia_trees_prop ~ ssp_prop + ssp_vol, data) 
# Отбор предикторов по критерию Акаике
ia_tree_prop_model <- stepAIC(ia_tree_prop_model, trace=0) 
# сводка по модели 
cat('Сводка по модели:', fill=T)
# summary(ia_tree_prop_model) 
knitr::kable(
  round(data.frame(summary(ia_tree_prop_model)$coefficients), digits=3),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(ia_tree_prop_model$residuals), 
      Q1 = quantile(ia_tree_prop_model$residuals, .25), 
      Median = quantile(ia_tree_prop_model$residuals, .5), 
      Q3 = quantile(ia_tree_prop_model$residuals, .75),
      Max. = max(ia_tree_prop_model$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
if(ia_tree_prop_model$rank < 3) {
  cat('Расчёт VIF не имеет смысла.')
} else {
  cat('VIF: ', vif(ia_tree_prop_model), '.', sep='', fill=T)
}
# Вывод графика реальных и предсказанных значений
plot(ia_tree_prop_model$model$ia_trees_prop, 
     ia_tree_prop_model$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
```



## Моделирование доли деревьев III–VI категорий 

Для моделирования этого признака сначала создадим модель суммарной доли деревьев I–II категорий состояния, а затем вычтем результат из 100%. Доля здоровых деревьев связана с поражённостью гнилями, богатством почвы и её увлажнённостью ([Интерпретация главной компоненты 1](#интерпретация-главной-компоненты-1)), доля ослабленных – с высотой древостоя ([Интерпретация главной компоненты 3](#интерпретация-главной-компоненты-3)).

```{r iii_to_vi_model, include=TRUE}
# вектор зависимых переменных (wod, weakened or dead)
wod <- 100 - (data$i + data$ii)
# фрейм для моделирования
wod <- cbind(
  wod, 
  data[, c('ssp_height', 'rot', 'ram_hum', 'ram_troph', 'tsa_hum', 'tsa_troph')]
)
# линейная модель
wod_model <- lm(wod ~ ., wod)
# Отбор предикторов по критерию Акаике
wod_model <- stepAIC(wod_model, trace=0)
# сводка по модели 
cat('Сводка по модели:', fill=T)
knitr::kable(
  round(data.frame(summary(wod_model)$coefficients), digits=3),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(wod_model$residuals), 
      Q1 = quantile(wod_model$residuals, .25), 
      Median = quantile(wod_model$residuals, .5), 
      Q3 = quantile(wod_model$residuals, .75),
      Max. = max(wod_model$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
if(wod_model$rank < 3) {
  cat('Расчёт VIF не имеет смысла.')
} else {
  cat('VIF: ', vif(wod_model), '.', sep='', fill=T)
}
# Вывод графика реальных и предсказанных значений
plot(wod_model$model$wod, 
     wod_model$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
# удалим временный объект
rm(wod)
```

| Модель совершенно неуспешна. 

## Моделирование доли здоровых деревьев

Для моделирования этого признака рассмотрим зависимость от поражённости гнилями, богатства и увлажнённости почвы по Раменскому ([Интерпретация главной компоненты 1](#интерпретация-главной-компоненты-1)). 

| От характеристики по шкалам Цаценкина отказываюсь, так как Раменский показал лучшие результаты на предварительном этапе. 

```{r i_model, include=TRUE}
# линейная модель
i_model <- lm(i ~ rot + ram_troph + ram_hum, data)
# Отбор предикторов по критерию Акаике
i_model <- stepAIC(i_model, trace=0)
# сводка по модели 
cat('Сводка по модели:', fill=T)
knitr::kable(
  round(data.frame(summary(i_model)$coefficients), digits=3),
  caption = 'Коэффициенты модели')
knitr::kable(
  round(
    data.frame(
      Min. = min(i_model$residuals), 
      Q1 = quantile(i_model$residuals, .25), 
      Median = quantile(i_model$residuals, .5), 
      Q3 = quantile(i_model$residuals, .75),
      Max. = max(i_model$residuals)
      ), 
    digits=3),
  caption = 'Описательные статистики')
cat(rep('-', 20), fill=T)
# коэффициент инфляции дисперсии (проверка избыточности признаков) 
if(i_model$rank < 3) {
  cat('Расчёт VIF не имеет смысла.')
} else {
  cat('VIF: ', vif(i_model), '.', sep='', fill=T)
}
# Вывод графика реальных и предсказанных значений
plot(i_model$model$i, 
     i_model$fitted.values, 
     xlab='Реальные значения', 
     ylab='Предсказанные значения')
grid()
abline(0, 1)
```

# Дополнительный материал

## Расшифровка использованных признаков {#расшифровка-использованных-признаков}

| Код признака| Расшифровка | Тип данных |
|-|-|-|
| ssp_prop | Доля кедра в древостое | количественный |
| ssp_age | Возраст кедра | количественный |
| ssp_age_sd | Возраста кедра, стандартное отклонение | количественный |
| ssp_diam | Диаметр кедра | количественный |
| ssp_diam_sd | Диаметр кедра, стандартное отклонение | количественный |
| ssp_height | Высота кедра | количественный |
| ssp_height_sd | Высота кедра, стандартное отклонение | количественный |
| ssp_vol | Объём стволовой древесины кедра | количественный |
| overall_vol | Объём стволовой древесины всех пород | количественный |
| density | Полнота | количественный |
| forest_type | Тип леса | номинальный |
| ia_density | Плотность поселения союзного короеда, общая | количественный |
| ia_density_par | Плотность поселения союзного короеда, родительское поколение | количественный |
| ia_gallery_length | Длина маточных ходов | количественный |
| ia_trees_prop | Доля деревьев, заселённых союзным короедом | количественный |
| rot | Доля гнили в стволах кедра по объёму | количественный |
| Pschw | Наличие деревьев, поражённых трутовиком Швейница | булев |
| Arm | То же, опёнком  | булев |
| Fros | То же, трутовиком розовым  | булев |
| Fpin | То же, сосновой губкой | булев |
| Hann  | То же, корневой губкой  | булев |
| Phchrys | То же, еловой губкой  | булев |
| Lshulph | То же, трутовиком серно-жёлтым  | булев |
| Tab | То же, трихаптумом еловым | булев |
| Gluc | То же, трутовиком лакированным | булев |
| Gsep | То же, трутовиком заборным | булев |
| br  | То же, ржавчинным раком | булев |
| Nec | То же, нектриевым раком | булев |
| necr | То же, некрозами | булев |
| i | Доля здоровых деревьев | количественный |
| ii | То же, ослабленных | количественный |
| iii | То же, сильно ослабленных | количественный |
| iv | То же, усыхающих | количественный |
| v | То же, свежего сухостоя | количественный |
| vi | То же, старого сухостоя | количественный |
| ram_hum | Балл увлажнённости по Раменскому  | количественный |
| ram_troph | Балл трофности по Раменскому  | количественный |
| tsa_hum | Балл увлажнённости по Цаценкину | количественный |
| tsa_troph | Балл трофности по Цаценкину | количественный |
| rw_before | Средняя ширина годичного кольца до начала инвазии (2001--2010 гг.)  | количественный |
| rw_after  | То же, после начала инвазии (2011--2020 гг.)  | количественный |
| trend_before | Линейный коэффициент уравнения прироста до 2010 г. | количественный |
| trend_after | То же, после 2010 г.  | количественный |
| temp_whole_prev_may | Наличие реакции радиального прироста на температуры мая предыдущего сезона за весь период наблюдений | номинальный |
| temp_whole_prev_aug | То же, для августа  | номинальный |
| temp_whole_prev_sep | То же, для сентября | номинальный |
| temp_whole_prev_oct | То же, для октября  | номинальный |
| temp_whole_prev_nov | То же, для ноября | номинальный |
| temp_whole_curr_jan | Наличие реакции радиального прироста на температуры января текущего сезона за весь период наблюдений | номинальный |
| temp_whole_curr_mar | То же, для марта | номинальный |
| temp_whole_curr_may | То же, для мая | номинальный |
| temp_whole_curr_jun | То же, для июня | номинальный |
| prec_whole_prev_feb | Наличие реакции радиального прироста на осадки февраля предыдущего сезона за весь период наблюдений | номинальный |
| prec_whole_prev_apr | То же, для марта | номинальный |
| prec_whole_prev_may | То же, для мая | номинальный |
| prec_whole_prev_jun | То же, для июня | номинальный |
| prec_whole_prev_jul | То же, для июля | номинальный |
| prec_whole_prev_aug | То же, для августа | номинальный |
| prec_whole_prev_nov | То же, для ноября | номинальный |
| prec_whole_curr_jan | Наличие реакции радиального прироста на осадки января текущего сезона за весь период наблюдений | номинальный |
| prec_whole_curr_feb | То же для февраля | номинальный |
| prec_whole_curr_may | То же, для мая | номинальный |
| prec_whole_curr_jun | То же, для июня | номинальный |
| prec_whole_curr_jul | То же, для июля | номинальный |
| prec_whole_curr_sep | То же, для сентября | номинальный |
| lat | Широта  | количественный |
| lon | Долгота | количественный |

## Графический анализ: связи между характеристиками древостоев

Пары признаков, для которых готовили графики, выбирали как в [Графический анализ: графы связей](#графический-анализ-графы-связей).

```{r graphical_analysis_of_relations, include=TRUE, warning=FALSE}
for(i in 1:(ncol(data) - 1)) {
  j <- i + 1
  while(j <= ncol(data)) { 
    if(mode(data[, i]) == 'numeric' & mode(data[, j]) == 'numeric') {
      tmp <- cor.test(data[, i], data[, j], method='spearman')
      if(tmp$p.value <= .05) plot(data[, i], data[, j], 
                                  xlab=colnames(data)[i], 
                                  ylab=colnames(data)[j])
    }
    if(mode(data[, i]) == 'character' & mode(data[, j]) == 'character') {
      tmp <- chisq.test(data[, i], data[, j])
      if(tmp$p.value <= .05) barplot(table(data[, i], data[, j]), 
                                     xlab=colnames(data)[j], 
                                     ylab=colnames(data)[i], 
                                     legend=T)
    }
    if(mode(data[, i]) != mode(data[, j])) {
      if(mode(data[, i]) == 'numeric') {
        quan <- data[, i]
        qual <- data[, j]
        name_quan <- colnames(data)[i]
        name_qual <- colnames(data)[j]
      } else {
        quan <- data[, j]
        qual <- data[, i]
        name_quan <- colnames(data)[j]
        name_qual <- colnames(data)[i]
      }
        tmp <- kruskal.test(quan, qual)
        if(tmp$p.value <= .05) boxplot(quan ~ qual, 
                                       xlab=name_qual, 
                                       ylab=name_quan)
    }
    j <- j + 1
  }
  rm(j, tmp, quan, qual, name_quan, name_qual)
}
rm(i)
```
